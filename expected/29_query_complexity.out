-- Test complex query patterns and advanced SQL features
-- Ensures pg_stat_insights handles sophisticated queries correctly
-- Test 1: Reset statistics
SELECT pg_stat_insights_reset();
ERROR:  function pg_stat_insights_reset() does not exist
LINE 1: SELECT pg_stat_insights_reset();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- Test 2: Create test schema with multiple related tables
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    order_date TIMESTAMP,
    total_amount DECIMAL(10,2)
);
CREATE TABLE order_items (
    item_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id),
    product_name VARCHAR(100),
    quantity INT,
    price DECIMAL(10,2)
);
-- Test 3: Insert relational data
INSERT INTO customers (name, email)
SELECT 
    'Customer_' || i,
    'customer' || i || '@test.com'
FROM generate_series(1, 100) i;
INSERT INTO orders (customer_id, order_date, total_amount)
SELECT 
    (i % 100) + 1,
    '2025-11-01 00:00:00'::TIMESTAMP - (i || ' hours')::INTERVAL,
    (i * 25.50)::DECIMAL(10,2)
FROM generate_series(1, 300) i;
INSERT INTO order_items (order_id, product_name, quantity, price)
SELECT 
    (i % 300) + 1,
    'Product_' || (i % 50),
    (i % 10) + 1,
    ((i % 20) * 5.99)::DECIMAL(10,2)
FROM generate_series(1, 600) i;
-- Test 4: Complex multi-table joins
SELECT c.name, COUNT(o.order_id) AS order_count, SUM(o.total_amount) AS total_spent
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name
HAVING COUNT(o.order_id) > 0
ORDER BY total_spent DESC
LIMIT 10;
     name     | order_count | total_spent 
--------------+-------------+-------------
 Customer_1   |           3 |    15300.00
 Customer_100 |           3 |    15223.50
 Customer_99  |           3 |    15147.00
 Customer_98  |           3 |    15070.50
 Customer_97  |           3 |    14994.00
 Customer_96  |           3 |    14917.50
 Customer_95  |           3 |    14841.00
 Customer_94  |           3 |    14764.50
 Customer_93  |           3 |    14688.00
 Customer_92  |           3 |    14611.50
(10 rows)

-- Test 5: Nested subqueries with aggregates
SELECT 
    customer_id,
    (SELECT COUNT(*) FROM orders WHERE customer_id = c.customer_id) AS order_count,
    (SELECT SUM(total_amount) FROM orders WHERE customer_id = c.customer_id) AS total_spent
FROM customers c
WHERE customer_id IN (
    SELECT customer_id 
    FROM orders 
    GROUP BY customer_id 
    HAVING COUNT(*) > 2
)
ORDER BY customer_id
LIMIT 10;
 customer_id | order_count | total_spent 
-------------+-------------+-------------
           1 |           3 |    15300.00
           2 |           3 |     7726.50
           3 |           3 |     7803.00
           4 |           3 |     7879.50
           5 |           3 |     7956.00
           6 |           3 |     8032.50
           7 |           3 |     8109.00
           8 |           3 |     8185.50
           9 |           3 |     8262.00
          10 |           3 |     8338.50
(10 rows)

-- Test 6: CTEs with window functions
WITH order_stats AS (
    SELECT 
        customer_id,
        order_id,
        total_amount,
        ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY total_amount DESC) AS rank,
        SUM(total_amount) OVER (PARTITION BY customer_id) AS customer_total
    FROM orders
)
SELECT * FROM order_stats WHERE rank <= 3 ORDER BY customer_id, rank LIMIT 15;
 customer_id | order_id | total_amount | rank | customer_total 
-------------+----------+--------------+------+----------------
           1 |      300 |      7650.00 |    1 |       15300.00
           1 |      200 |      5100.00 |    2 |       15300.00
           1 |      100 |      2550.00 |    3 |       15300.00
           2 |      201 |      5125.50 |    1 |        7726.50
           2 |      101 |      2575.50 |    2 |        7726.50
           2 |        1 |        25.50 |    3 |        7726.50
           3 |      202 |      5151.00 |    1 |        7803.00
           3 |      102 |      2601.00 |    2 |        7803.00
           3 |        2 |        51.00 |    3 |        7803.00
           4 |      203 |      5176.50 |    1 |        7879.50
           4 |      103 |      2626.50 |    2 |        7879.50
           4 |        3 |        76.50 |    3 |        7879.50
           5 |      204 |      5202.00 |    1 |        7956.00
           5 |      104 |      2652.00 |    2 |        7956.00
           5 |        4 |       102.00 |    3 |        7956.00
(15 rows)

-- Test 7: Recursive CTE
WITH RECURSIVE number_series AS (
    SELECT 1 AS n
    UNION ALL
    SELECT n + 1 FROM number_series WHERE n < 20
)
SELECT n, n * n AS square, n * n * n AS cube
FROM number_series
ORDER BY n;
 n  | square | cube 
----+--------+------
  1 |      1 |    1
  2 |      4 |    8
  3 |      9 |   27
  4 |     16 |   64
  5 |     25 |  125
  6 |     36 |  216
  7 |     49 |  343
  8 |     64 |  512
  9 |     81 |  729
 10 |    100 | 1000
 11 |    121 | 1331
 12 |    144 | 1728
 13 |    169 | 2197
 14 |    196 | 2744
 15 |    225 | 3375
 16 |    256 | 4096
 17 |    289 | 4913
 18 |    324 | 5832
 19 |    361 | 6859
 20 |    400 | 8000
(20 rows)

-- Test 8: Complex CASE expressions
SELECT 
    customer_id,
    CASE 
        WHEN total_amount < 100 THEN 'Small'
        WHEN total_amount < 500 THEN 'Medium'
        WHEN total_amount < 1000 THEN 'Large'
        ELSE 'Enterprise'
    END AS order_size,
    COUNT(*) AS count
FROM orders
GROUP BY customer_id, 
    CASE 
        WHEN total_amount < 100 THEN 'Small'
        WHEN total_amount < 500 THEN 'Medium'
        WHEN total_amount < 1000 THEN 'Large'
        ELSE 'Enterprise'
    END
ORDER BY customer_id, order_size
LIMIT 20;
 customer_id | order_size | count 
-------------+------------+-------
           1 | Enterprise |     3
           2 | Enterprise |     2
           2 | Small      |     1
           3 | Enterprise |     2
           3 | Small      |     1
           4 | Enterprise |     2
           4 | Small      |     1
           5 | Enterprise |     2
           5 | Medium     |     1
           6 | Enterprise |     2
           6 | Medium     |     1
           7 | Enterprise |     2
           7 | Medium     |     1
           8 | Enterprise |     2
           8 | Medium     |     1
           9 | Enterprise |     2
           9 | Medium     |     1
          10 | Enterprise |     2
          10 | Medium     |     1
          11 | Enterprise |     2
(20 rows)

-- Test 9: LATERAL joins
SELECT c.name, recent_orders.order_count, recent_orders.recent_total
FROM customers c
CROSS JOIN LATERAL (
    SELECT 
        COUNT(*) AS order_count,
        SUM(total_amount) AS recent_total
    FROM orders o
    WHERE o.customer_id = c.customer_id
      AND o.order_date > NOW() - INTERVAL '7 days'
) recent_orders
WHERE recent_orders.order_count > 0
ORDER BY recent_orders.recent_total DESC
LIMIT 10;
    name     | order_count | recent_total 
-------------+-------------+--------------
 Customer_85 |           1 |      2142.00
 Customer_84 |           1 |      2116.50
 Customer_83 |           1 |      2091.00
 Customer_82 |           1 |      2065.50
 Customer_81 |           1 |      2040.00
 Customer_80 |           1 |      2014.50
 Customer_79 |           1 |      1989.00
 Customer_78 |           1 |      1963.50
 Customer_77 |           1 |      1938.00
 Customer_76 |           1 |      1912.50
(10 rows)

-- Test 10: DISTINCT ON with complex ordering
SELECT DISTINCT ON (customer_id) 
    customer_id,
    order_id,
    total_amount,
    order_date
FROM orders
ORDER BY customer_id, total_amount DESC, order_date DESC
LIMIT 10;
 customer_id | order_id | total_amount |        order_date        
-------------+----------+--------------+--------------------------
           1 |      300 |      7650.00 | Sun Oct 19 12:00:00 2025
           2 |      201 |      5125.50 | Thu Oct 23 15:00:00 2025
           3 |      202 |      5151.00 | Thu Oct 23 14:00:00 2025
           4 |      203 |      5176.50 | Thu Oct 23 13:00:00 2025
           5 |      204 |      5202.00 | Thu Oct 23 12:00:00 2025
           6 |      205 |      5227.50 | Thu Oct 23 11:00:00 2025
           7 |      206 |      5253.00 | Thu Oct 23 10:00:00 2025
           8 |      207 |      5278.50 | Thu Oct 23 09:00:00 2025
           9 |      208 |      5304.00 | Thu Oct 23 08:00:00 2025
          10 |      209 |      5329.50 | Thu Oct 23 07:00:00 2025
(10 rows)

-- Test 11: Verify complex queries are tracked
SELECT COUNT(*) >= 8 AS tracked_complex_queries
FROM pg_stat_insights
WHERE query LIKE '%customers%' OR query LIKE '%orders%'
  AND query NOT LIKE '%pg_stat_insights%';
ERROR:  relation "pg_stat_insights" does not exist
LINE 2: FROM pg_stat_insights
             ^
-- Test 12: Check for recursive CTE tracking
SELECT COUNT(*) >= 1 AS tracked_recursive_cte
FROM pg_stat_insights
WHERE query LIKE '%RECURSIVE%';
ERROR:  relation "pg_stat_insights" does not exist
LINE 2: FROM pg_stat_insights
             ^
-- Test 13: Verify JOIN tracking
SELECT COUNT(*) >= 2 AS tracked_joins
FROM pg_stat_insights
WHERE query LIKE '%JOIN%'
  AND query NOT LIKE '%pg_stat_insights%';
ERROR:  relation "pg_stat_insights" does not exist
LINE 2: FROM pg_stat_insights
             ^
-- Test 14: Check window function tracking
SELECT COUNT(*) >= 1 AS tracked_window_functions
FROM pg_stat_insights
WHERE query LIKE '%OVER%'
  AND query NOT LIKE '%pg_stat_insights%';
ERROR:  relation "pg_stat_insights" does not exist
LINE 2: FROM pg_stat_insights
             ^
-- Test 15: Verify all tracked queries have valid statistics
SELECT 
    COUNT(*) AS total_queries,
    COUNT(*) FILTER (WHERE calls > 0) AS queries_with_calls,
    COUNT(*) FILTER (WHERE total_exec_time >= 0) AS queries_with_time,
    COUNT(*) FILTER (WHERE mean_exec_time >= 0) AS queries_with_mean
FROM pg_stat_insights
WHERE query NOT LIKE '%pg_stat_insights%';
ERROR:  relation "pg_stat_insights" does not exist
LINE 6: FROM pg_stat_insights
             ^
-- Test 16: Cleanup
DROP TABLE order_items;
DROP TABLE orders;
DROP TABLE customers;
-- Test 17: Final statistics check
SELECT COUNT(*) >= 0 AS stats_available_after_cleanup
FROM pg_stat_insights
WHERE query LIKE '%customers%' OR query LIKE '%orders%';
ERROR:  relation "pg_stat_insights" does not exist
LINE 2: FROM pg_stat_insights
             ^
-- Test 18: Reset
SELECT pg_stat_insights_reset();
ERROR:  function pg_stat_insights_reset() does not exist
LINE 1: SELECT pg_stat_insights_reset();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
